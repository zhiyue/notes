* sicp
#+TITLE: Structure and Interpretation of Computer Programs

http://mitpress.mit.edu/sicp/

** 序言
你所知道的有关计算的东西，其他人也都能学到。绝不要认为似乎成功计算的钥匙就掌握在你的手里。你所掌握的，也是我认为并且希望的，也就是智慧：那种看到这一机器比你第一次站在它面前时能够做的更多的能力，这样你才能将它向前推进。

一台计算机就像是把小提琴。你可以想象一个新手试了一个音符并且立刻丢弃它。后来他说，听起来真难听。我们已经从大众和我们的大部分计算机科学家那里反复听到这种说法。他们说，计算机程序对个别具体用途而言确实是好东西，但是他们太缺乏弹性了。一把小提琴或者是一台打字机也能够同样缺乏弹性，那时你学会了如何使用它们之前。

note(dirlt): 这本书是我在大四的时候看的。当时只是觉得封面很有神秘感，里面的代码似乎和我以前写过的代码方式差别很大，也没有完全看懂（现在也没有完全看懂，不确定求值没有看懂，第五章没有静下心看）。对于语言层面的认识基本上忘了，只记得有用惰性求值(lazy eval)来解决无限流问题，用eval+apply来表达程序运行的本质等。但是当时有一点让我印象深刻，就是这么简单的语言能够组合得这么强大并且如此具有表示力。

note(dirlt @ 2014.12.25): revisit :)

SICP1的封面和SICP2的封面

file:./images/SICP.jpg file:./images/SICP2.fix.jpg

** 构造抽象过程
心智的活动除了尽力产生各种简单的认识外，主要表现在(组合，对比，抽象):
   1. 将若干简单认识组合称为复合认识，由此产生复杂的认识。
   2. 将两个认识放在一起对照，不管简单还是复杂，由此得到它们之间的相互关系的认识。
   3. 将有关认识和实际中和它们所在的认识隔离开，就是抽象，所有具有普遍性的认识都是这样得到的。

一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。这样当我们描述一个语言时，就需要将注意力特别放在这一语言提供的，能够将简单的认识组合起来形成更复杂认识的方法方面。每一种强有力的语言为此提供了三种机制：
   1. 基本表达式，用于表示语言所关心的最简单的个体。
   2. 组合的方法，通过它们可以从简单的东西出发构造出复合的元素。
   3. 抽象的方法，通过它们可以为复合对象命名，并将它们当作单元去操作。

求值模型：1) 正则序(normal order)：完全展开而后归约。2) 应用序(apply order)：先求值参数而后应用，这是通常的实现方式。下面这段代码可以检测解释器使用哪种求值模型：
#+BEGIN_SRC Scheme
(define loop
  (lambda () (loop)))
(define test
  (lambda (x y)
    (cond ((zero? x) 0)
          (else y))))
(test 0 (loop))
#+END_SRC
其实这个例子也解释了为什么(if ...)不能够使用function而必须使用macro来实现。

一般而言，程序设计语言总会对计算元素的可能使用方式强加上某些限制。带有最少限制的元素被成为具有第一级的状态。第一级元素的某些“权利或者特权”包括：# note(dirlt): first-citizen.
- 可以用变量命名
- 可以提供给过程作为参数
- 可以由过程作为结果返回
- 可以包含在数据结构中
Lisp不像其他程序设计语言，它给了过程完全的第一级状态。这就给有效实现提出了挑战，但由此所获得的描述能力却是极其惊人的。

** 构造数据抽象
现在到了数学抽象中最关键的一步:让我们忘记这些符号所表示的对象。数学家不应该在这里停步，有许多操作可以应用于这些符号，而根本不必考虑它们代表什么。

car = Contents of Address part of Register. cdr = Contents of Decrement part of Register.

我们也对程序设计的另一个关键概念有了一点认识，这就是分层设计的问题。这一概念说的是，一个复杂的系统应该通过一系列的层次构造出来，为了描述这些层次，需要使用一系列的语言。构造这个层次的方式，就是设法组合起作为这一层次中部件的各种基本元素，而这样构造出的部件又可以作为另一个层次里的基本元素。在分层设计中，每个层次上所用的语言都提供了一些基本元素，组合手段，还有对这该层次中的适当细节做抽象的手段。

在最后一个参数之前加上.可以将剩余的参数作为列表赋给最后一个参数。类似C里面的vargs, 用来解决变长参数问题。
#+BEGIN_SRC Scheme
(define foo
  (lambda (x . ls)
    (+ x (apply max ls))))
(display (foo 1 2 3 4)) ; 1 + (max 2 3 4) = 5
#+END_SRC

** 模块化，对象和状态
惰性求值需要环境提供两个函数delay和force. 其中delay传入函数f返回一个延迟对象，而force作用在这个延迟对象上就可以执行f. 很明显delay需要使用宏来实现
#+BEGIN_SRC Scheme
(define-syntax delay
  (syntax-rules ()
    ((delay exp)
      (lambda () exp))))
(define force
  (lambda (delayed) (delayed)))

;; an example
(define x (delay (begin
                   (display "hello")
                   (newline))))
(force x)
#+END_SRC

使用惰性求值可以很容易地实现无穷流/列表。为了实现无穷流我们还需要重新定义一下列表的基本操作cons, car, cdr. 列表car是一个具体数值，cdr则是一个需要延迟计算的过程
#+BEGIN_SRC Scheme
(define-syntax s-cons
  (syntax-rules ()
    ((s-cons x y) (cons x (delay y)))))
(define s-car
  (lambda (s) (car s)))
(define s-cdr
  (lambda (s) (force (cdr s))))
(define s-map
  (lambda (f . ss)
    (s-cons (apply f (map s-car ss))
            (apply s-map (cons f (map s-cdr ss))))))
(define s-nth
  (lambda (n s)
    (let recur ((n n) (s s))
      (cond
        ((zero? n) (s-car s))
        (else (recur (- n 1) (s-cdr s)))))))
#+END_SRC

这里我们以fibonacci序列为例
#+BEGIN_SRC Scheme
(define fibs
  (s-cons 1 (s-cons 1 (s-map + fibs (s-cdr fibs)))))
(display (s-nth 30 fibs))
#+END_SRC
输出结果是1346269. 但是在我的guile上面计算非常慢花费近5s.

和之前学习C语言计算fib一样，我们可以将已经计算的结果缓存起来。我们编写memorize函数并且修改delay.
#+BEGIN_SRC Scheme
(define memorize
  (lambda (f)
    (let ((already? #f) (cache #f))
      (lambda ()
        (cond
         (already? cache)
         (else (begin
                 (set! already? #t)
                 (set! cache (f))
                 cache)))))))
(define-syntax delay
  (syntax-rules ()
    ((delay exp)
     (memorize
      (lambda () exp)))))
#+END_SRC
然后我们继续取(s-nth 30 fibs). 计算就非常快速大约0.07s.

** 元语言抽象
真正的魔力在于知道哪个咒语有用，在什么时候，用于做什么，其诀窍就在于学会有关的诀窍。而这些咒语也使用我们的字母表里面的字母拼出来的，这些字母表中不过是几十个可以用笔画话出来的弯弯曲线。这就是最关键的！而这些珍宝也是如此，如果我们能将它们拿到手的话。这就像是说，就像通向珍宝的钥匙是珍宝。

建立新语言是在工程设计中控制复杂性的一种威力强大的工作策略，通常能够采用一种新语言提升处理复杂问题的能力，因为新语言能够使我们以一种完全不同的方式，利用不同原语组合方式和抽象方式去描述(思考)所面临的问题，而这些都可以是为了手头需要处理的问题专门打造的。元语言抽象就是建立新的语言。

file:./images/SICP-eval-apply.png

note(dirlt): 这个模型还是无法阐释清楚Lisp系统里的控制机制，比如值是如何返回的以及函数是如何调用的。所以才引入了后面一章在寄存器机器模型上的计算。

有一件很有教益的事情，那就是将非确定性求值和流处理中引起的不同时间图景做一个比较。流处理中利用惰性求值，设法去松弛装配出可能回答的流的时间与时间的流元素产生出来的时间的关系。这种求值器支持这样一种错觉，好像所有可能的结果都是以一种无时间顺序的的方式摆在我们面前。对于非确定性的求值，一个表达式表示的是对于一集可能世界的探索，其中每一个都由一集选择所确定。某些可能世界将走入死胡同，而另外一些则保存着有用的值。非确定性程序求值器支持另外一种假象：时间是有分支的，而我们的程序里保存这所有可能的不同执行历史。在遇到一个死胡同时，我们总可以回到以前的某个选择点，并沿着另一个分支继续下去。

自动魔法般地：“自动地，但是以一种由于某些原因（典型的情况是它太复杂，或者太丑陋，或者甚至太简单），而使说话者并不喜欢去解释的方式。”

** 寄存器机器里的计算
我的目的是想说明，这一天空机器并不是一种天赐造物或者生命体，它只不过是钟表一类的机械装置（而那些相信中标有灵魂的人却将这一工作说成是其创造者的荣耀），在很大程度上，这里多种多样的运动都是由最简单的物质力量产生的，就像钟表里所有的活动都是由一个发条产生的一样。
